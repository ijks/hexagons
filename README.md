# hexagons
Making an infinite labyrinth made out of hexagonal pieces. Inspired by the Library of Babel, and specifically an online interpretation of it (see below).

## The Labyrinth
The labyrinth consists of an infinite hexagonal rooms, that connect to each other through at least 1, and at most 2 passageways (otherwise there would not be enough room for bookshelves). There should be no isolated clusters â€” every room should be reachable (eventually) from every other room.

## Labyrinth Generation
Existing maze generation algorithms assume a finite grid, so we can't use those. I did find one algorithm that was claimed to be able to generate infinite mazes, but seemed those could only be infinite in one direction.

I think the best solution would be a cellular automaton. Each hex tile uses information of its surroundings to determine whether it should become a room or not, and whether it should have 1 or 2 openings, and where. An empty tile can only become a room if at least one of its neighbors. This makes it easy to tweak the density of the labyrinth (i.e. how many of the space is taken up by rooms), and should definitely guarantee that there are no isolated clusters, since every room is connected to at least one pre-existing room, and that room to another, etc. (yay for induction) For efficiency, the generation is split up in chunks, and a chunk is generated by running the cellular automaton until it is certain that no new rooms will be generated; in other words, once it has reached an equilibrium.

I do think there is a downside to this approach: we wouldn't be able to generate any new chunks that are isolated, but would always have to start from existing generated chunks. If a player were to teleport to a far away location in the labyrinth, we would have to generate all chunks leading to that location. We also wouldn't be able to search for texts in the library like libraryofbabel.info does.

The solution to this problem would be to use a pure but pseudorandom function to generate the labyrinth. But I have no idea how to come up with such a function that meets the requirements outlined above. So I will just implement the CA approach first, and see if I get any other ideas.

## References
* Hexagons: http://www.redblobgames.com/grids/hexagons/
* The Library of Babel: https://libraryofbabel.info/
  - specifically: https://libraryofbabel.info/theory.html
* https://jaspervdj.be/posts/2015-03-13-practical-testing-in-haskell.html
